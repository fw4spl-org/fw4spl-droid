buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:1.2.+'
    }
}

apply plugin: 'com.android.application'

dependencies {
    compile fileTree(dir: 'libs', include: '*.jar')
}

android {

    compileSdkVersion ${ANDROID_API_LEVEL}
    
    defaultConfig {
        minSdkVersion ${ANDROID_MIN_API_LEVEL}
        targetSdkVersion ${ANDROID_API_LEVEL}
    }

    signingConfigs 
    {
          release 
          {
              storeFile file('${ANDROID_APK_KEYSTORE}')
              storePassword '${ANDROID_APK_KEYSTORE_PWD}'
              keyAlias '${ANDROID_APK_KEY_ALIAS}'
              keyPassword '${ANDROID_APK_KEY_PWD}'
          }
      }
   
    buildTypes 
    {
        debug 
        {
            // minifyEnabled true
            applicationVariants.all 
        }
        release 
        {

            debuggable false
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-project.txt')
            signingConfig signingConfigs.release
                
        }
        
        applicationVariants.all { variant ->
            variant.outputs.each { output ->
                  def alignedOutputFile = output.outputFile
                  def unalignedOutputFile = output.packageApplication.outputFile
                 
                   if(output.zipAlign) {
                       if(buildTypes)
                       output.outputFile = new File(alignedOutputFile.parent, '${BASE_APP_NAME}' + '-' + variant.buildType.name + '.apk')
                   }
 
                   output.packageApplication.outputFile = new File(unalignedOutputFile.parent,'${BASE_APP_NAME}' + '-' + variant.buildType.name + '-unaligned' + '.apk')

               }
           }
        

        jnidebug.initWith(buildTypes.debug)
        jnidebug {
            jniDebuggable true
        }
    }

    sourceSets {
        main {
            manifest.srcFile 'AndroidManifest.xml'
            java.srcDirs = ['src']
            resources.srcDirs = ['src']
            aidl.srcDirs = ['src']
            renderscript.srcDirs = ['src']
            res.srcDirs = ['res']
            assets.srcDirs = ['assets']
            jniLibs.srcDirs = ['libs']
        }
    }

    packagingOptions {
        exclude 'META-INF/LICENSE.txt'
        exclude 'META-INF/NOTICE.txt'
    }
}

//
// get the installed SDK and build tools version
// based on: http://www.egeek.me/2013/12/07/gradle-auto-detect-android-sdk-and-build-tools-versions/
// modified by Ari Ayvazyan
import org.codehaus.groovy.runtime.StackTraceUtils


public String androidSDKDir() {
    def sdkDir = android.getSdkDirectory().toString()
    return sdkDir
}

public int[] sdksAvailable() {
    def sdks = new ByteArrayOutputStream()
    def androidSdkDir = androidSDKDir()
    exec {
        workingDir androidSdkDir + "/tools"
        if(isWindows()) {
            commandLine 'cmd', '/c','android', 'list'
        } else {
            commandLine './android', 'list'
        }
        standardOutput = sdks
    }
    sdks = sdks
    // get the output
            .toString()
    // split to strings
            .split('\n')
    // leave only strings with API levels
            .findAll { it ==~ /\s*API level:\s*(\d+).*/ }
    // extract the API levels
            .collect { (it =~ /\s*API level:\s*(\d+).*/)[0][1].toInteger() }
    // sort from highest to lowest
            .sort( { a, b -> b <=> a } )
    sdks
}

public int highestSdkAvailable(int preferredSdk) {
    try {
        def sdks = sdksAvailable()
        def highestSdk = sdks[0]
        if (highestSdk == null) {
            println "No installed SDKs found. Using default SDK " + preferredSdk
            return preferredSdk
        }else if(sdks.contains(preferredSdk)) {
            println "Preferred SDK found, using: " + preferredSdk
            return preferredSdk
        }else{
            println "Using latest found SDK " + highestSdk
            return highestSdk
        }
    } catch (any) {
        println "Exception while determining highest SDK. Using default SDK " +
                preferredSdk
        StackTraceUtils.sanitize(any).printStackTrace()
        preferredSdk
    }
}

public String[] buildToolsAvailable() {
    println "sdk dir: " + androidSDKDir()
    def buildToolsDir = new File(androidSDKDir(), "build-tools")
    buildToolsDir.list([accept:{d, f-> !f.contains("android") }] as FilenameFilter).sort { a, b -> b <=> a }
}

public String latestBuildToolsAvailable(String defaultBuildTools) {
    try {
        def buildToolsVersions = buildToolsAvailable()
        def latestBuildTools = buildToolsVersions[0]
        if (latestBuildTools != null) {
            println "Using latest found build tools " + latestBuildTools
            latestBuildTools
        } else {
            println "No installed build tools found. Using default build tools " +
                    defaultBuildTools
            defaultBuildTools
        }
    } catch (any) {
        println "Exception while determining latest build tools. Using default build tools " +
                defaultBuildTools
        StackTraceUtils.sanitize(any).printStackTrace()
        defaultBuildTools
    }
}

import org.apache.tools.ant.taskdefs.condition.Os
public boolean isWindows() {
    if (Os.isFamily(Os.FAMILY_WINDOWS)) {
        return true
    }
    return false
}

// android.compileSdkVersion = highestSdkAvailable(19)
android.buildToolsVersion = latestBuildToolsAvailable("19.0.0")
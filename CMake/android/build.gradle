/**
 * The buildscript {} block is where you configure the repositories and
 * dependencies for Gradle itself--meaning, you should not include dependencies
 * for your modules here. For example, this block includes the Android plugin for
 * Gradle as a dependency because it provides the additional instructions Gradle
 * needs to build Android app modules.
 */

buildscript {

    /**
     * The repositories {} block configures the repositories Gradle uses to
     * search or download the dependencies. Gradle pre-configures support for remote
     * repositories such as JCenter, Maven Central, and Ivy. You can also use local
     * repositories or define your own remote repositories. The code below defines
     * JCenter as the repository Gradle should use to look for its dependencies.
     */

    repositories {
        jcenter()
    }

    /**
     * The dependencies {} block configures the dependencies Gradle needs to use
     * to build your project. The following line adds Android Plugin for Gradle
     * version 1.3.1 as a classpath dependency. 
     * We currently encountred some issue with higher versions
     */

    dependencies {
        classpath 'com.android.tools.build:gradle:1.3.1'
    }
}

/**
 * The first line in the build configuration applies the Android plugin for
 * Gradle to this build and makes the android {} block available to specify
 * Android-specific build options.
 */

apply plugin: 'com.android.application'

/**
 * The android {} block is where you configure all your Android-specific
 * build options.
 */

android {

    // Defines API level used to compile.
    compileSdkVersion ${ANDROID_API_LEVEL}
    
    defaultConfig {
        
        // Defines the minimum API level required to run the app.
        minSdkVersion ${ANDROID_MIN_API_LEVEL}
        
        // Specifies the API level used to test the app.
        targetSdkVersion ${ANDROID_API_LEVEL}
    }

    signingConfigs 
    {
          release 
          {
              storeFile file('${ANDROID_APK_KEYSTORE}')
              storePassword '${ANDROID_APK_KEYSTORE_PWD}'
              keyAlias '${ANDROID_APK_KEY_ALIAS}'
              keyPassword '${ANDROID_APK_KEY_PWD}'
          }
      }
   
   
     /**
      * The buildTypes {} block is where you can configure multiple build types.
      * By default, the build system defines two build types: debug and release. The
      * debug build type is not explicitly shown in the default build configuration,
      * but it includes debugging tools and is signed with the debug key. The release
      * build type applies Proguard settings and is not signed by default.
      */
   
    buildTypes 
    {
        debug 
        {
            // minifyEnabled true
            applicationVariants.all
            jniDebuggable true

            ndk {
                debuggable = true
            }
        }
        
       /**
        * By default, Android Studio configures the release build type to enable code
        * shrinking, using minifyEnabled, and specifies the Proguard settings file.
        */
        release 
        {

            debuggable false
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.release
                
        }
        
        applicationVariants.all { variant ->
            variant.outputs.each { output ->
                  def alignedOutputFile = output.outputFile
                  def unalignedOutputFile = output.packageApplication.outputFile
                 
                   if(variant.buildType.name == 'debug') {
                       // if(buildTypes)
                       output.outputFile = new File(alignedOutputFile.parent, '${BASE_APP_NAME}' + '-' + variant.buildType.name + '.apk')
                   }
 
                   // output.packageApplication.outputFile = new File(unalignedOutputFile.parent,'${BASE_APP_NAME}' + '-' + variant.buildType.name + '-unaligned' + '.apk')

               }
           }
    }

    sourceSets {
        main {
            manifest.srcFile 'AndroidManifest.xml'
            java.srcDirs = ['src']
            resources.srcDirs = ['src']
            aidl.srcDirs = ['src']
            renderscript.srcDirs = ['src']
            res.srcDirs = ['res']
            assets.srcDirs = ['assets']
            jniLibs.srcDirs = ['libs']
        }
    }

    packagingOptions {
        exclude 'META-INF/LICENSE.txt'
        exclude 'META-INF/NOTICE.txt'
    }
}

/**
 * The dependencies {} block in the module-level build configuration file
 * only specifies dependencies required to build the module itself.
 */
dependencies {
    compile fileTree(dir: 'libs', include: '*.jar')
}


//

// get the installed SDK and build tools version
// based on: http://www.egeek.me/2013/12/07/gradle-auto-detect-android-sdk-and-build-tools-versions/
// modified by Ari Ayvazyan
import org.codehaus.groovy.runtime.StackTraceUtils


public String androidSDKDir() {
    def sdkDir = android.getSdkDirectory().toString()
    return sdkDir
}

public int[] sdksAvailable() {
    def sdks = new ByteArrayOutputStream()
    def androidSdkDir = androidSDKDir()
    exec {
        workingDir androidSdkDir + "/tools"
        if(isWindows()) {
            commandLine 'cmd', '/c','android', 'list'
        } else {
            commandLine './android', 'list'
        }
        standardOutput = sdks
    }
    sdks = sdks
    // get the output
            .toString()
    // split to strings
            .split('\n')
    // leave only strings with API levels
            .findAll { it ==~ /\s*API level:\s*(\d+).*/ }
    // extract the API levels
            .collect { (it =~ /\s*API level:\s*(\d+).*/)[0][1].toInteger() }
    // sort from highest to lowest
            .sort( { a, b -> b <=> a } )
    sdks
}

public int highestSdkAvailable(int preferredSdk) {
    try {
        def sdks = sdksAvailable()
        def highestSdk = sdks[0]
        if (highestSdk == null) {
            println "No installed SDKs found. Using default SDK " + preferredSdk
            return preferredSdk
        }else if(sdks.contains(preferredSdk)) {
            println "Preferred SDK found, using: " + preferredSdk
            return preferredSdk
        }else{
            println "Using latest found SDK " + highestSdk
            return highestSdk
        }
    } catch (any) {
        println "Exception while determining highest SDK. Using default SDK " +
                preferredSdk
        StackTraceUtils.sanitize(any).printStackTrace()
        preferredSdk
    }
}

public String[] buildToolsAvailable() {
    println "sdk dir: " + androidSDKDir()
    def buildToolsDir = new File(androidSDKDir(), "build-tools")
    buildToolsDir.list([accept:{d, f-> !f.contains("android") }] as FilenameFilter).sort { a, b -> b <=> a }
}

public String latestBuildToolsAvailable(String defaultBuildTools) {
    try {
        def buildToolsVersions = buildToolsAvailable()
        def latestBuildTools = buildToolsVersions[0]
        if (latestBuildTools != null) {
            println "Using latest found build tools " + latestBuildTools
            latestBuildTools
        } else {
            println "No installed build tools found. Using default build tools " +
                    defaultBuildTools
            defaultBuildTools
        }
    } catch (any) {
        println "Exception while determining latest build tools. Using default build tools " +
                defaultBuildTools
        StackTraceUtils.sanitize(any).printStackTrace()
        defaultBuildTools
    }
}

import org.apache.tools.ant.taskdefs.condition.Os
public boolean isWindows() {
    if (Os.isFamily(Os.FAMILY_WINDOWS)) {
        return true
    }
    return false
}

// android.compileSdkVersion = highestSdkAvailable(19)
android.buildToolsVersion = latestBuildToolsAvailable("19.0.0")